<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Swarm Field Theory Calculator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root{
      --bg:#0f1724;
      --ink:#e6eef8;
      --muted:#95a3b8;
      --rule:#1b2942;
      --accent:#7ccfff;
      --panel:#101a2b;
      --radius:10px;
      --wrap:960px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      color:var(--ink);
      line-height:1.5;
      padding-bottom:3rem;
    }
    header{
      border-bottom:1px solid var(--rule);
      background:rgba(15,23,36,.6);
      backdrop-filter:blur(4px);
    }
    .topbar{
      max-width:var(--wrap);
      margin:0 auto;
      padding:1rem 1rem;
      display:flex;
      justify-content:space-between;
      align-items:center;
    }
    h1{font-size:1.35rem;margin:0}
    main{max-width:var(--wrap);margin:2rem auto;padding:0 1rem}
    .grid{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(210px,1fr));
      gap:1rem;
      margin-bottom:1.5rem;
    }
    label{display:block;font-weight:600;margin-bottom:.25rem}
    input{
      width:100%;
      background:#0b111c;
      border:1px solid #1f2b42;
      border-radius:6px;
      padding:.4rem .5rem;
      color:var(--ink);
    }
    small{color:var(--muted);display:block;margin-top:.25rem;font-size:.7rem}
    button{
      background:var(--accent);
      border:none;
      padding:.55rem 1.2rem;
      border-radius:6px;
      font-weight:600;
      cursor:pointer;
      color:#001323;
      margin-bottom:1.5rem;
    }
    table{
      width:100%;
      border-collapse:collapse;
      overflow:hidden;
      border-radius:10px;
      margin-bottom:1.5rem;
    }
    th,td{
      padding:.55rem .5rem;
      border-bottom:1px solid rgba(255,255,255,.03);
      text-align:left;
      font-size:.8rem;
    }
    th{
      background:rgba(16,26,43,.5);
      font-size:.7rem;
      text-transform:uppercase;
      letter-spacing:.04em
    }
    tr:nth-child(even){background:rgba(255,255,255,.01)}
    .tag{background:rgba(124,207,255,.15);color:var(--accent);padding:.2rem .45rem;border-radius:999px;font-size:.65rem}
    .panel{
      background:rgba(16,26,43,.35);
      border:1px solid rgba(255,255,255,.02);
      border-radius:10px;
      padding:1rem 1.2rem;
      margin-top:2rem;
    }
    a{color:var(--accent)}
    h2{margin-top:2.5rem}
  </style>
</head>
<body>
  <header>
    <div class="topbar">
      <h1>Swarm Field Theory · Lattice / Closure Calculator</h1>
      <span class="tag">from Excel 08 NOV 2025 v3</span>
    </div>
  </header>
  <main>
    <nav>
      <a href="index.html">← Back to Home</a>
    </nav>
    <p>This page reproduces the logic of the Excel workbook: Inputs → Derivations → Planck/Compton → Route B closure → Extended outputs → External predictions. Change λ, κ, N, Φ or the closure factor C to see how constants and G move. Note that the precision of the online calculator may not match that of the Excel Spreadsheet due to roundings and internal calculation methodology.  THe logic is the same as the Excel Spreadsheet.</p>

    <!-- INPUTS -->
    <div class="grid">
      <div>
        <label for="lambda">λ (coherence aperture) [m]</label>
        <input id="lambda" type="number" step="any" value="8.2e-10">
        <small>Inputs!C2 (≈ 8.20×10⁻¹⁰ m)</small>
      </div>
      <div>
        <label for="kappa">κ (helical projection)</label>
        <input id="kappa" type="number" step="any" value="0.92203">
        <small>Inputs!C3</small>
      </div>
      <div>
        <label for="N">N (rotational count)</label>
        <input id="N" type="number" step="any" value="11.80388">
        <small>Inputs!C4</small>
      </div>
      <div>
        <label for="phi">Φ (packing factor)</label>
        <input id="phi" type="number" step="any" value="2.447640847537652">
        <small>Inputs!C5</small>
      </div>
      <div>
        <label for="Ccorr">C (discrete Gauss normalisation)</label>
        <input id="Ccorr" type="number" step="any" value="1.00794648">
        <small>Inputs!C6 · set to 1 to disable Route B correction</small>
      </div>
    </div>

    <button onclick="runCalc()">Compute</button>

    <!-- CORE -->
    <h2>Core derived quantities</h2>
    <table id="core">
      <thead>
        <tr>
          <th>Parameter</th>
          <th>Name</th>
          <th>Predicted value</th>
          <th>Units</th>
          <th>Reference</th>
          <th>Δ %</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <!-- PLANCK / COMPTON -->
    <h2>Planck / Compton zone</h2>
    <table id="planck">
      <thead>
        <tr>
          <th>Parameter</th>
          <th>Description</th>
          <th>Value</th>
          <th>Units</th>
          <th>Reference</th>
          <th>Δ %</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <!-- CLOSURE -->
    <h2>Gravitational closure (Route B)</h2>
    <table id="closure">
      <thead>
        <tr>
          <th>Parameter</th>
          <th>Description</th>
          <th>Value</th>
          <th>Units</th>
          <th>CODATA</th>
          <th>Δ %</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <!-- EXTENDED OUTPUTS -->
    <h2>Extended outputs (Planck, atomic, EM)</h2>
    <table id="extended">
      <thead>
        <tr>
          <th>Parameter</th>
          <th>Name</th>
          <th>Predicted</th>
          <th>Units</th>
          <th>Reference</th>
          <th>Δ %</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <!-- EXTERNAL PREDICTIONS -->
    <h2>External predictions</h2>

    <h3>Schwarzschild radius: r<sub>s</sub> = 2 G M / c²</h3>
    <table id="schwarzschild">
      <thead>
        <tr>
          <th>Body</th>
          <th>Mass [kg]</th>
          <th>rₛ (G<sub>model</sub>) [m]</th>
          <th>rₛ (G<sub>CODATA</sub>) [m]</th>
          <th>Δ %</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <h3>Surface gravity: g = G M / R²</h3>
    <table id="gravity">
      <thead>
        <tr>
          <th>Body</th>
          <th>Mass [kg]</th>
          <th>Radius [m]</th>
          <th>g (model) [m/s²]</th>
          <th>g (CODATA) [m/s²]</th>
          <th>g (observed) [m/s²]</th>
          <th>Δ % vs CODATA</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <h3>Gravitational wave speed</h3>
    <table id="gw">
      <thead>
        <tr>
          <th>Quantity</th>
          <th>Value [m/s]</th>
          <th>Reference [m/s]</th>
          <th>Δ %</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <h3>Orbital relations (Kepler & circular motion)</h3>
    <table id="orbit">
      <thead>
        <tr>
          <th>System</th>
          <th>a / r [m]</th>
          <th>Predicted</th>
          <th>Observed / Ref</th>
          <th>Δ %</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <!-- FOOTER -->
    <div class="panel">
      <h3 style="margin-top:0">Downloads & references</h3>
      <p>This calculator mirrors the spreadsheet published on Zenodo.</p>
      <p><strong>Current record:</strong>
        <a href="https://doi.org/10.5281/zenodo.17561178" target="_blank" rel="noopener">
          https://doi.org/10.5281/zenodo.17561178
        </a>
      </p>
      <p><small>© 2025 J. Paul Crumpler, PE — Swarm Field Theory Project.</small></p>
    </div>
  </main>

  <script>
    // SI / reference constants (as in your Constants sheet)
    const c_SI     = 299792458;                  // m/s
    const h_SI     = 6.62607015e-34;             // J·s
    const hbar     = h_SI / (2*Math.PI);         // J·s
    const e_SI     = 1.602176634e-19;            // C
    const eps0_SI  = 8.8541878128e-12;           // F/m
    const mu0_SI   = 1.25663706212e-6;           // H/m
    const alpha_SI = 0.0072973525693;            // —
    const G_SI     = 6.6743e-11;                 // m^3 kg^-1 s^-2
    const m_e      = 9.1093837015e-31;           // kg
    const m_p      = 1.67262192369e-27;          // kg
    const k_B      = 1.380649e-23;               // J/K

    // astronomy numbers taken from your Predictions_External sheet
    const M_EARTH  = 5.9722e24;
    const R_EARTH  = 6_371_000;
    const g_obs_earth = 9.80665;

    const M_SUN    = 1.9884699999999998e30;
    const R_SUN    = 696_340_000;
    const g_obs_sun = 274;

    // orbital inputs (same as sheet)
    const AU = 149_597_870_700;                  // m
    const MOON_DIST = 384_400_000;               // m
    const MOON_MASS = 7.34767309e22;             // kg
    const LEO_R = R_EARTH + 400_000;             // 400 km
    const ESC_R = R_EARTH;

    function pctDiff(pred, ref){
      if (!ref || ref === 0) return "";
      return ((pred - ref)/ref*100).toFixed(6);
    }
    function toSci(x){
      if (!isFinite(x)) return "";
      return x.toExponential(8);
    }

    function runCalc(){
      const lambda = parseFloat(document.getElementById('lambda').value);
      const kappa  = parseFloat(document.getElementById('kappa').value);
      const N      = parseFloat(document.getElementById('N').value);
      const phi    = parseFloat(document.getElementById('phi').value);
      const Ccorr  = parseFloat(document.getElementById('Ccorr').value);

      // 1) τ = κ λ / c
      const tau = kappa * lambda / c_SI;

      // 2) ΔI = ħ / (π λ² τ)
      const deltaI = hbar / (Math.PI * lambda * lambda * tau);

      // 3) ξ_base = κ / (2 √(π N))
      const xi_base = kappa / (2 * Math.sqrt(Math.PI * N));

      // 4) ξ_geom = xi_base * Φ
      const xi_geom = xi_base * phi;

      // 5) α_pred = (ξ_geom² / 4) * κ²
      const alpha_pred = (xi_geom*xi_geom / 4) * (kappa*kappa);

      // 6) ε0_pred = e² /(4 π α_pred ħ c)
      const eps0_pred = (e_SI*e_SI) / (4*Math.PI*alpha_pred*hbar*c_SI);

      // 7) μ0_pred = 1/(eps0_pred c²)
      const mu0_pred = 1/(eps0_pred * c_SI * c_SI);

      // 8) Θ_geom_base = κ³ α_pred¹¹ /(4 π N Φ)
      const theta_geom_base = (Math.pow(kappa,3) * Math.pow(alpha_pred,11)) / (4*Math.PI * N * phi);

      // G_base from your formula
      const G_base = Math.PI*Math.PI * Math.pow(c_SI,5)/hbar * Math.pow(tau * theta_geom_base, 2);

      // corrected
      const theta_geom_corr = Ccorr * theta_geom_base;
      const G_corr = Math.PI*Math.PI * Math.pow(c_SI,5)/hbar * Math.pow(tau * theta_geom_corr, 2);

      // Swarm-derived Planck constant
      const h_pred = 2 * Math.PI * Math.PI * deltaI * lambda * lambda * tau;

      // Compton
      const lambda_e_pred = h_pred / (m_e * c_SI);
      const lambda_p_pred = h_pred / (m_p * c_SI);

      /* --------- CORE TABLE ---------- */
      const coreBody = document.querySelector('#core tbody');
      coreBody.innerHTML = `
        <tr>
          <td>τ</td>
          <td>Coherence time constant</td>
          <td>${toSci(tau)}</td>
          <td>s</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>ΔI</td>
          <td>Coherence membrane tension</td>
          <td>${toSci(deltaI)}</td>
          <td>J·m⁻²</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>α (pred)</td>
          <td>Fine-structure (Swarm)</td>
          <td>${toSci(alpha_pred)}</td>
          <td>dimensionless</td>
          <td>${alpha_SI.toExponential(8)}</td>
          <td>${pctDiff(alpha_pred, alpha_SI)}</td>
        </tr>
        <tr>
          <td>ε₀ (pred)</td>
          <td>Vacuum permittivity</td>
          <td>${toSci(eps0_pred)}</td>
          <td>F·m⁻¹</td>
          <td>${eps0_SI.toExponential(8)}</td>
          <td>${pctDiff(eps0_pred, eps0_SI)}</td>
        </tr>
        <tr>
          <td>μ₀ (pred)</td>
          <td>Vacuum permeability</td>
          <td>${toSci(mu0_pred)}</td>
          <td>H·m⁻¹</td>
          <td>${mu0_SI.toExponential(8)}</td>
          <td>${pctDiff(mu0_pred, mu0_SI)}</td>
        </tr>
        <tr>
          <td>Θ_geom_base</td>
          <td>Base geometric closure term</td>
          <td>${toSci(theta_geom_base)}</td>
          <td>m³·kg⁻¹·s⁻²</td>
          <td></td>
          <td></td>
        </tr>
      `;

      /* --------- PLANCK / COMPTON TABLE ---------- */
      const planckBody = document.querySelector('#planck tbody');
      planckBody.innerHTML = `
        <tr>
          <td>h (pred)</td>
          <td>Planck’s constant from Swarm geometry</td>
          <td>${toSci(h_pred)}</td>
          <td>J·s</td>
          <td>${h_SI.toExponential(8)}</td>
          <td>${pctDiff(h_pred, h_SI)}</td>
        </tr>
        <tr>
          <td>λₑ (pred)</td>
          <td>Electron Compton wavelength (from h_pred)</td>
          <td>${toSci(lambda_e_pred)}</td>
          <td>m</td>
          <td>${(h_SI/(m_e*c_SI)).toExponential(8)}</td>
          <td>${pctDiff(lambda_e_pred, h_SI/(m_e*c_SI))}</td>
        </tr>
        <tr>
          <td>λₚ (pred)</td>
          <td>Proton Compton wavelength (from h_pred)</td>
          <td>${toSci(lambda_p_pred)}</td>
          <td>m</td>
          <td>${(h_SI/(m_p*c_SI)).toExponential(8)}</td>
          <td>${pctDiff(lambda_p_pred, h_SI/(m_p*c_SI))}</td>
        </tr>
      `;

      /* --------- CLOSURE TABLE ---------- */
      const closeBody = document.querySelector('#closure tbody');
      closeBody.innerHTML = `
        <tr>
          <td>G_base</td>
          <td>Gravitational constant (Route B, C=1)</td>
          <td>${toSci(G_base)}</td>
          <td>m³·kg⁻¹·s⁻²</td>
          <td>${G_SI.toExponential(8)}</td>
          <td>${pctDiff(G_base, G_SI)}</td>
        </tr>
        <tr>
          <td>C</td>
          <td>Discrete Gauss normalisation</td>
          <td>${Ccorr}</td>
          <td>unitless</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>Θ_geom (Route B)</td>
          <td>Geometric closure term with C</td>
          <td>${toSci(theta_geom_corr)}</td>
          <td>m³·kg⁻¹·s⁻²</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>G (Route B corrected)</td>
          <td>Predicted G with C applied</td>
          <td>${toSci(G_corr)}</td>
          <td>m³·kg⁻¹·s⁻²</td>
          <td>${G_SI.toExponential(8)}</td>
          <td>${pctDiff(G_corr, G_SI)}</td>
        </tr>
      `;

      /* --------- EXTENDED OUTPUTS ---------- */
      // Coulomb constant
      const k_e = 1 / (4 * Math.PI * eps0_pred);
      // free space impedance
      const Z0 = mu0_pred * c_SI;
      // Stefan–Boltzmann
      const sigma = 2 * Math.pow(Math.PI,5) * Math.pow(k_B,4) / (15 * c_SI*c_SI * Math.pow(h_pred,3));
      // Planck units
      const t_P = Math.sqrt(hbar * G_corr / Math.pow(c_SI,5));
      const l_P = Math.sqrt(hbar * G_corr / Math.pow(c_SI,3));
      const m_P = Math.sqrt(hbar * c_SI / G_corr);
      const E_P = m_P * c_SI * c_SI;
      const q_P = Math.sqrt(4 * Math.PI * eps0_pred * hbar * c_SI);
      // atomic
      const a0 = 4 * Math.PI * eps0_pred * hbar * hbar / (m_e * e_SI * e_SI);
      const r_e = e_SI*e_SI / (4 * Math.PI * eps0_pred * m_e * c_SI * c_SI);
      const lambda_C_e = h_pred / (m_e * c_SI);
      const lambda_C_e_bar = hbar / (m_e * c_SI);
      const R_inf = alpha_pred*alpha_pred * m_e * c_SI / (2 * h_pred);
      const E_h = alpha_pred*alpha_pred * m_e * c_SI * c_SI;
      const mu_B = e_SI * hbar / (2 * m_e);
      const mu_N = e_SI * hbar / (2 * m_p);
      const lambda_C_p = h_pred / (m_p * c_SI);
      const lambda_C_p_bar = hbar / (m_p * c_SI);
      const mu_red = (m_e * m_p) / (m_e + m_p);
      const a0_H = 4 * Math.PI * eps0_pred * hbar * hbar / (mu_red * e_SI * e_SI);
      const R_H = R_inf / (1 + m_e / m_p);

      const extBody = document.querySelector('#extended tbody');
      extBody.innerHTML = `
        <tr>
          <td>k_e</td>
          <td>Coulomb’s constant</td>
          <td>${toSci(k_e)}</td>
          <td>N·m²·C⁻²</td>
          <td>${(1/(4*Math.PI*eps0_SI)).toExponential(8)}</td>
          <td>${pctDiff(k_e, 1/(4*Math.PI*eps0_SI))}</td>
        </tr>
        <tr>
          <td>Z₀</td>
          <td>Vacuum impedance</td>
          <td>${toSci(Z0)}</td>
          <td>Ω</td>
          <td>${(mu0_SI * c_SI).toExponential(8)}</td>
          <td>${pctDiff(Z0, mu0_SI * c_SI)}</td>
        </tr>
        <tr>
          <td>σ</td>
          <td>Stefan–Boltzmann constant</td>
          <td>${toSci(sigma)}</td>
          <td>W·m⁻²·K⁻⁴</td>
          <td>${(5.670374419e-8).toExponential(8)}</td>
          <td>${pctDiff(sigma, 5.670374419e-8)}</td>
        </tr>
        <tr>
          <td>t_P</td>
          <td>Planck time</td>
          <td>${toSci(t_P)}</td>
          <td>s</td>
          <td>${(5.391246e-44).toExponential(8)}</td>
          <td>${pctDiff(t_P, 5.391246e-44)}</td>
        </tr>
        <tr>
          <td>l_P</td>
          <td>Planck length</td>
          <td>${toSci(l_P)}</td>
          <td>m</td>
          <td>${(1.616255e-35).toExponential(8)}</td>
          <td>${pctDiff(l_P, 1.616255e-35)}</td>
        </tr>
        <tr>
          <td>m_P</td>
          <td>Planck mass</td>
          <td>${toSci(m_P)}</td>
          <td>kg</td>
          <td>${(2.176434e-8).toExponential(8)}</td>
          <td>${pctDiff(m_P, 2.176434e-8)}</td>
        </tr>
        <tr>
          <td>E_P</td>
          <td>Planck energy</td>
          <td>${toSci(E_P)}</td>
          <td>J</td>
          <td>${(1.956082e9).toExponential(8)}</td>
          <td>${pctDiff(E_P, 1.956082e9)}</td>
        </tr>
        <tr>
          <td>q_P</td>
          <td>Planck charge</td>
          <td>${toSci(q_P)}</td>
          <td>C</td>
          <td>${(1.875546e-18).toExponential(8)}</td>
          <td>${pctDiff(q_P, 1.875546e-18)}</td>
        </tr>
        <tr>
          <td>a₀</td>
          <td>Bohr radius</td>
          <td>${toSci(a0)}</td>
          <td>m</td>
          <td>${(5.29177210903e-11).toExponential(8)}</td>
          <td>${pctDiff(a0, 5.29177210903e-11)}</td>
        </tr>
        <tr>
          <td>rₑ</td>
          <td>Classical electron radius</td>
          <td>${toSci(r_e)}</td>
          <td>m</td>
          <td>${(2.8179403262e-15).toExponential(8)}</td>
          <td>${pctDiff(r_e, 2.8179403262e-15)}</td>
        </tr>
        <tr>
          <td>λ_C (e)</td>
          <td>Compton wavelength of electron</td>
          <td>${toSci(lambda_C_e)}</td>
          <td>m</td>
          <td>${(h_SI/(m_e*c_SI)).toExponential(8)}</td>
          <td>${pctDiff(lambda_C_e, h_SI/(m_e*c_SI))}</td>
        </tr>
        <tr>
          <td>λ̄_C (e)</td>
          <td>Reduced Compton wavelength of electron</td>
          <td>${toSci(lambda_C_e_bar)}</td>
          <td>m</td>
          <td>${(hbar/(m_e*c_SI)).toExponential(8)}</td>
          <td>${pctDiff(lambda_C_e_bar, hbar/(m_e*c_SI))}</td>
        </tr>
        <tr>
          <td>R_∞</td>
          <td>Rydberg constant</td>
          <td>${toSci(R_inf)}</td>
          <td>m⁻¹</td>
          <td>${(1.0973731568160e7).toExponential(8)}</td>
          <td>${pctDiff(R_inf, 1.0973731568160e7)}</td>
        </tr>
        <tr>
          <td>E_h</td>
          <td>Hartree energy</td>
          <td>${toSci(E_h)}</td>
          <td>J</td>
          <td>${(4.3597447222071e-18).toExponential(8)}</td>
          <td>${pctDiff(E_h, 4.3597447222071e-18)}</td>
        </tr>
        <tr>
          <td>μ_B</td>
          <td>Bohr magneton</td>
          <td>${toSci(mu_B)}</td>
          <td>J·T⁻¹</td>
          <td>${(9.2740100783e-24).toExponential(8)}</td>
          <td>${pctDiff(mu_B, 9.2740100783e-24)}</td>
        </tr>
        <tr>
          <td>μ_N</td>
          <td>Nuclear magneton</td>
          <td>${toSci(mu_N)}</td>
          <td>J·T⁻¹</td>
          <td>${(5.0507837461e-27).toExponential(8)}</td>
          <td>${pctDiff(mu_N, 5.0507837461e-27)}</td>
        </tr>
        <tr>
          <td>λ_C (p)</td>
          <td>Compton wavelength of proton</td>
          <td>${toSci(lambda_C_p)}</td>
          <td>m</td>
          <td>${(h_SI/(m_p*c_SI)).toExponential(8)}</td>
          <td>${pctDiff(lambda_C_p, h_SI/(m_p*c_SI))}</td>
        </tr>
        <tr>
          <td>λ̄_C (p)</td>
          <td>Reduced Compton wavelength of proton</td>
          <td>${toSci(lambda_C_p_bar)}</td>
          <td>m</td>
          <td>${(hbar/(m_p*c_SI)).toExponential(8)}</td>
          <td>${pctDiff(lambda_C_p_bar, hbar/(m_p*c_SI))}</td>
        </tr>
        <tr>
          <td>μ_red (e–p)</td>
          <td>Reduced mass of e–p system</td>
          <td>${toSci(mu_red)}</td>
          <td>kg</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>a₀,H</td>
          <td>Bohr radius (reduced-mass corrected)</td>
          <td>${toSci(a0_H)}</td>
          <td>m</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>R_H</td>
          <td>Rydberg const. for hydrogen</td>
          <td>${toSci(R_H)}</td>
          <td>m⁻¹</td>
          <td>${(1.096776e7).toExponential(8)}</td>
          <td>${pctDiff(R_H, 1.096776e7)}</td>
        </tr>
      `;

      /* --------- EXTERNAL PREDICTIONS ---------- */

      // Schwarzschild
      const schBody = document.querySelector('#schwarzschild tbody');
      const bodies = [
        {name:"Earth", M:M_EARTH},
        {name:"Sun",   M:M_SUN}
      ];
      schBody.innerHTML = bodies.map(b => {
        const rs_model = 2 * G_corr * b.M / (c_SI*c_SI);
        const rs_ref   = 2 * G_SI   * b.M / (c_SI*c_SI);
        return `<tr>
          <td>${b.name}</td>
          <td>${toSci(b.M)}</td>
          <td>${toSci(rs_model)}</td>
          <td>${toSci(rs_ref)}</td>
          <td>${pctDiff(rs_model, rs_ref)}</td>
        </tr>`;
      }).join("");

      // Surface gravity
      const gBody = document.querySelector('#gravity tbody');
      gBody.innerHTML = `
        <tr>
          <td>Earth</td>
          <td>${toSci(M_EARTH)}</td>
          <td>${R_EARTH.toLocaleString()}</td>
          <td>${(G_corr * M_EARTH / (R_EARTH*R_EARTH)).toPrecision(10)}</td>
          <td>${(G_SI   * M_EARTH / (R_EARTH*R_EARTH)).toPrecision(10)}</td>
          <td>${g_obs_earth}</td>
          <td>${pctDiff(G_corr * M_EARTH / (R_EARTH*R_EARTH), G_SI * M_EARTH / (R_EARTH*R_EARTH))}</td>
        </tr>
        <tr>
          <td>Sun</td>
          <td>${toSci(M_SUN)}</td>
          <td>${R_SUN.toLocaleString()}</td>
          <td>${(G_corr * M_SUN / (R_SUN*R_SUN)).toPrecision(10)}</td>
          <td>${(G_SI   * M_SUN / (R_SUN*R_SUN)).toPrecision(10)}</td>
          <td>${g_obs_sun}</td>
          <td>${pctDiff(G_corr * M_SUN / (R_SUN*R_SUN), G_SI * M_SUN / (R_SUN*R_SUN))}</td>
        </tr>
      `;

      // GW speed
      const gwBody = document.querySelector('#gw tbody');
      gwBody.innerHTML = `
        <tr>
          <td>c_GW (model)</td>
          <td>${c_SI}</td>
          <td>${c_SI}</td>
          <td>0.000000</td>
        </tr>
      `;

   // Orbits
const orbitBody = document.querySelector('#orbit tbody');

// ---- Kepler systems use total mass (primary + secondary) ----

// Earth about Sun
const mu_earth_sun   = G_corr * (M_SUN + M_EARTH);
const T_earth_sun_pred = 2 * Math.PI * Math.sqrt(Math.pow(AU, 3) / mu_earth_sun);
// use the same observed/REFERENCE value you used in the spreadsheet:
const T_earth_sun_obs  = 31558149.7635456;  // s

// Moon about Earth
const mu_moon_earth  = G_corr * (M_EARTH + M_MOON);
const T_moon_pred    = 2 * Math.PI * Math.sqrt(Math.pow(MOON_DIST, 3) / mu_moon_earth);
const T_moon_obs     = 2360591.5104;        // s

// LEO 400 km (satellite mass negligible)
const v_LEO_pred = Math.sqrt(G_corr * M_EARTH / LEO_R);
const v_LEO_obs  = 7670;

// Escape from Earth surface
const v_esc_pred = Math.sqrt(2 * G_corr * M_EARTH / ESC_R);
const v_esc_obs  = 11186;

orbitBody.innerHTML = `
  <tr>
    <td>Earth ↺ Sun — Kepler period T</td>
    <td>${AU.toLocaleString()}</td>
    <td>${T_earth_sun_pred.toPrecision(11)} s</td>
    <td>${T_earth_sun_obs} s</td>
    <td>${pctDiff(T_earth_sun_pred, T_earth_sun_obs)}</td>
  </tr>
  <tr>
    <td>Moon ↺ Earth — Kepler period T</td>
    <td>${MOON_DIST.toLocaleString()}</td>
    <td>${T_moon_pred.toPrecision(11)} s</td>
    <td>${T_moon_obs} s</td>
    <td>${pctDiff(T_moon_pred, T_moon_obs)}</td>
  </tr>
  <tr>
    <td>LEO @ 400 km — circular speed v</td>
    <td>${LEO_R.toLocaleString()}</td>
    <td>${v_LEO_pred.toPrecision(7)} m/s</td>
    <td>${v_LEO_obs} m/s</td>
    <td>${pctDiff(v_LEO_pred, v_LEO_obs)}</td>
  </tr>
  <tr>
    <td>Earth surface — escape speed v_esc</td>
    <td>${ESC_R.toLocaleString()}</td>
    <td>${v_esc_pred.toPrecision(7)} m/s</td>
    <td>${v_esc_obs} m/s</td>
    <td>${pctDiff(v_esc_pred, v_esc_obs)}</td>
  </tr>
`;
    }

    // initial run
    runCalc();
  </script>
</body>
</html>
