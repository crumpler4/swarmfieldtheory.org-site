<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Swarm Field Theory Calculator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root{
      --bg:#0f1724;
      --ink:#e6eef8;
      --muted:#95a3b8;
      --rule:#1b2942;
      --accent:#7ccfff;
      --panel:#101a2b;
      --radius:10px;
      --wrap:960px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      color:var(--ink);
      line-height:1.5;
      padding-bottom:3rem;
    }
    header{
      border-bottom:1px solid var(--rule);
      background:rgba(15,23,36,.6);
      backdrop-filter:blur(4px);
    }
    .topbar{
      max-width:var(--wrap);
      margin:0 auto;
      padding:1rem 1rem;
      display:flex;
      justify-content:space-between;
      align-items:center;
    }
    h1{font-size:1.35rem;margin:0}
    main{max-width:var(--wrap);margin:2rem auto;padding:0 1rem}
    .grid{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(210px,1fr));
      gap:1rem;
      margin-bottom:1.5rem;
    }
    label{display:block;font-weight:600;margin-bottom:.25rem}
    input{
      width:100%;
      background:#0b111c;
      border:1px solid #1f2b42;
      border-radius:6px;
      padding:.4rem .5rem;
      color:var(--ink);
    }
    small{color:var(--muted);display:block;margin-top:.25rem;font-size:.7rem}
    button{
      background:var(--accent);
      border:none;
      padding:.55rem 1.2rem;
      border-radius:6px;
      font-weight:600;
      cursor:pointer;
      color:#001323;
      margin-bottom:1.5rem;
    }
    table{
      width:100%;
      border-collapse:collapse;
      overflow:hidden;
      border-radius:10px;
      margin-bottom:1.5rem;
    }
    th,td{
      padding:.55rem .5rem;
      border-bottom:1px solid rgba(255,255,255,.03);
      text-align:left;
      font-size:.8rem;
    }
    th{
      background:rgba(16,26,43,.5);
      font-size:.7rem;
      text-transform:uppercase;
      letter-spacing:.04em
    }
    tr:nth-child(even){background:rgba(255,255,255,.01)}
    .tag{background:rgba(124,207,255,.15);color:var(--accent);padding:.2rem .45rem;border-radius:999px;font-size:.65rem}
    .panel{
      background:rgba(16,26,43,.35);
      border:1px solid rgba(255,255,255,.02);
      border-radius:10px;
      padding:1rem 1.2rem;
      margin-top:2rem;
    }
    a{color:var(--accent)}
  </style>
</head>
<body>
  <header>
    <div class="topbar">
      <h1>Swarm Field Theory · Lattice / Closure Calculator</h1>
      <span class="tag">from Excel 08 NOV 2025 v3</span>
    </div>
  </header>
  <main>
    <nav>
        <a href="index.html">← Back to Home</a>
      </nav>
    <p>This page reproduces the logic of the Excel workbook: Inputs → Derivations → Planck/Compton → Route B closure. Change λ, κ, N, Φ or the closure factor C to see how constants and G move.</p>

    <div class="grid">
      <div>
        <label for="lambda">λ (coherence aperture) [m]</label>
        <input id="lambda" type="number" step="any" value="8.2e-10">
        <small>Inputs!C2 (≈ 8.20×10⁻¹⁰ m)</small>
      </div>
      <div>
        <label for="kappa">κ (helical projection)</label>
        <input id="kappa" type="number" step="any" value="0.92203">
        <small>Inputs!C3</small>
      </div>
      <div>
        <label for="N">N (rotational count)</label>
        <input id="N" type="number" step="any" value="11.80388">
        <small>Inputs!C4</small>
      </div>
      <div>
        <label for="phi">Φ (packing factor)</label>
        <input id="phi" type="number" step="any" value="2.447640847537652">
        <small>Inputs!C5</small>
      </div>
      <div>
        <label for="Ccorr">C (discrete Gauss normalisation)</label>
        <input id="Ccorr" type="number" step="any" value="1.00794648">
        <small>Inputs!C6 · set to 1 to disable Route B correction</small>
      </div>
    </div>

    <button onclick="runCalc()">Compute</button>

    <h2>Core derived quantities</h2>
    <table id="core">
      <thead>
        <tr>
          <th>Parameter</th>
          <th>Name</th>
          <th>Predicted value</th>
          <th>Units</th>
          <th>Reference</th>
          <th>Δ %</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <h2>Planck / Compton zone</h2>
    <table id="planck">
      <thead>
        <tr>
          <th>Parameter</th>
          <th>Description</th>
          <th>Value</th>
          <th>Units</th>
          <th>Reference</th>
          <th>Δ %</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <h2>Gravitational closure (Route B)</h2>
    <table id="closure">
      <thead>
        <tr>
          <th>Parameter</th>
          <th>Description</th>
          <th>Value</th>
          <th>Units</th>
          <th>CODATA</th>
          <th>Δ %</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <div class="panel">
      <h3 style="margin-top:0">Downloads & references</h3>
      <p>This calculator mirrors the spreadsheet published on Zenodo.</p>
      <p><strong>Current record:</strong> <a href="https://doi.org/10.5281/zenodo.17561178">https://doi.org/10.5281/zenodo.17561178</a></p>
      <p><small>© 2025 J. Paul Crumpler, PE — Swarm Field Theory Project.</small></p>
    </div>
  </main>

  <script>
    // Constants (mirroring your Constants sheet)
    const c_SI     = 299792458;                  // m/s
    const h_SI     = 6.62607015e-34;             // J·s
    const hbar     = h_SI / (2*Math.PI);         // J·s
    const e_SI     = 1.602176634e-19;            // C
    const eps0_SI  = 8.8541878128e-12;           // F/m
    const mu0_SI   = 1.25663706212e-6;           // H/m
    const alpha_SI = 0.0072973525693;            // fine-structure const
    const G_SI     = 6.6743e-11;                 // m^3 kg^-1 s^-2 (ref)
    // masses from your Constants sheet
    const m_e      = 9.1093837015e-31;           // kg
    const m_p      = 1.67262192369e-27;          // kg

    function pctDiff(pred, ref){
      if (!ref || ref === 0) return "";
      return ((pred - ref)/ref*100).toFixed(5);
    }
    function toSci(x){
      if (!isFinite(x)) return "";
      return x.toExponential(8);
    }

    function runCalc(){
      const lambda = parseFloat(document.getElementById('lambda').value);
      const kappa  = parseFloat(document.getElementById('kappa').value);
      const N      = parseFloat(document.getElementById('N').value);
      const phi    = parseFloat(document.getElementById('phi').value);
      const Ccorr  = parseFloat(document.getElementById('Ccorr').value);

      // 1) τ = κ λ / c
      const tau = kappa * lambda / c_SI;

      // 2) ΔI = ħ / (π λ² τ)
      const deltaI = hbar / (Math.PI * lambda * lambda * tau);

      // 3) ξ_base = κ / (2 √(π N))
      const xi_base = kappa / (2 * Math.sqrt(Math.PI * N));

      // 4) ξ_geom = ξ_base * Φ
      const xi_geom = xi_base * phi;

      // 5) α_pred = (ξ_geom² / 4) * κ²   ← matches your Derivations sheet
      const alpha_pred = (xi_geom*xi_geom / 4) * (kappa*kappa);

      // 6) ε0_pred = e² /(4 π α_pred ħ c)
      const eps0_pred = (e_SI*e_SI) / (4*Math.PI*alpha_pred*hbar*c_SI);

      // 7) μ0_pred = 1/(ε0_pred c²)
      const mu0_pred = 1/(eps0_pred * c_SI * c_SI);

      // 8) Θ_geom_base = κ³ α_pred¹¹ /(4 π N Φ)
      const theta_geom_base = (Math.pow(kappa,3) * Math.pow(alpha_pred,11)) / (4*Math.PI * N * phi);

      // --- Route B closure (from Closure_RouteB) ---
      // G_base (C = 1): = π² (c⁵/ħ) (τ Θ_geom_base)²
      const G_base = Math.PI*Math.PI * Math.pow(c_SI,5)/hbar * Math.pow(tau * theta_geom_base, 2);

      // Θ_geom (corrected) = C * Θ_geom_base
      const theta_geom_corr = Ccorr * theta_geom_base;

      // G_corrected = π² (c⁵/ħ) (τ Θ_geom_corr)²
      const G_corr = Math.PI*Math.PI * Math.pow(c_SI,5)/hbar * Math.pow(tau * theta_geom_corr, 2);

      // --- Swarm-derived Planck constant (from ΔI, λ, τ) ---
      // From: h = 2 π² ΔI λ² τ
      const h_pred = 2 * Math.PI * Math.PI * deltaI * lambda * lambda * tau;

      // --- Compton wavelengths using predicted h ---
      const lambda_e_pred = h_pred / (m_e * c_SI);
      const lambda_p_pred = h_pred / (m_p * c_SI);

      // fill core table
      const coreBody = document.querySelector('#core tbody');
      coreBody.innerHTML = `
        <tr>
          <td>τ</td>
          <td>Coherence time constant</td>
          <td>${toSci(tau)}</td>
          <td>s</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>ΔI</td>
          <td>Coherence membrane tension</td>
          <td>${toSci(deltaI)}</td>
          <td>J·m⁻²</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>α (pred)</td>
          <td>Fine-structure (Swarm)</td>
          <td>${toSci(alpha_pred)}</td>
          <td>dimensionless</td>
          <td>${alpha_SI.toExponential(8)}</td>
          <td>${pctDiff(alpha_pred, alpha_SI)}</td>
        </tr>
        <tr>
          <td>ε₀ (pred)</td>
          <td>Vacuum permittivity</td>
          <td>${toSci(eps0_pred)}</td>
          <td>F·m⁻¹</td>
          <td>${eps0_SI.toExponential(8)}</td>
          <td>${pctDiff(eps0_pred, eps0_SI)}</td>
        </tr>
        <tr>
          <td>μ₀ (pred)</td>
          <td>Vacuum permeability</td>
          <td>${toSci(mu0_pred)}</td>
          <td>H·m⁻¹</td>
          <td>${mu0_SI.toExponential(8)}</td>
          <td>${pctDiff(mu0_pred, mu0_SI)}</td>
        </tr>
        <tr>
          <td>Θ_geom_base</td>
          <td>Base geometric closure term</td>
          <td>${toSci(theta_geom_base)}</td>
          <td>m³·kg⁻¹·s⁻²</td>
          <td></td>
          <td></td>
        </tr>
      `;

      // fill planck/compton table
      const planckBody = document.querySelector('#planck tbody');
      planckBody.innerHTML = `
        <tr>
          <td>h (pred)</td>
          <td>Planck’s constant from Swarm geometry</td>
          <td>${toSci(h_pred)}</td>
          <td>J·s</td>
          <td>${h_SI.toExponential(8)}</td>
          <td>${pctDiff(h_pred, h_SI)}</td>
        </tr>
        <tr>
          <td>λₑ (pred)</td>
          <td>Electron Compton wavelength (from h_pred)</td>
          <td>${toSci(lambda_e_pred)}</td>
          <td>m</td>
          <td>${(h_SI/(m_e*c_SI)).toExponential(8)}</td>
          <td>${pctDiff(lambda_e_pred, h_SI/(m_e*c_SI))}</td>
        </tr>
        <tr>
          <td>λₚ (pred)</td>
          <td>Proton Compton wavelength (from h_pred)</td>
          <td>${toSci(lambda_p_pred)}</td>
          <td>m</td>
          <td>${(h_SI/(m_p*c_SI)).toExponential(8)}</td>
          <td>${pctDiff(lambda_p_pred, h_SI/(m_p*c_SI))}</td>
        </tr>
      `;

      // fill closure table
      const closeBody = document.querySelector('#closure tbody');
      closeBody.innerHTML = `
        <tr>
          <td>G_base</td>
          <td>Gravitational constant (Route B, C=1)</td>
          <td>${toSci(G_base)}</td>
          <td>m³·kg⁻¹·s⁻²</td>
          <td>${G_SI.toExponential(8)}</td>
          <td>${pctDiff(G_base, G_SI)}</td>
        </tr>
        <tr>
          <td>C</td>
          <td>Discrete Gauss normalisation</td>
          <td>${Ccorr}</td>
          <td>unitless</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>Θ_geom (Route B)</td>
          <td>Geometric closure term with C</td>
          <td>${toSci(theta_geom_corr)}</td>
          <td>m³·kg⁻¹·s⁻²</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>G (Route B corrected)</td>
          <td>Predicted G with C applied</td>
          <td>${toSci(G_corr)}</td>
          <td>m³·kg⁻¹·s⁻²</td>
          <td>${G_SI.toExponential(8)}</td>
          <td>${pctDiff(G_corr, G_SI)}</td>
        </tr>
      `;
    }

    // initial run
    runCalc();
  </script>
</body>
</html>
